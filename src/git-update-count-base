function git-update-count-base()
{
    local parse_regexp args_options
    local e_opt
    local number_only number_of_targets
    local parse_result

    args_options=($(echo $* | tr ' ' '\n' | sort | uniq | xargs))
    parse_regexp=""
    number_only=0
    number_of_targets=${#args_options}
    parse_result=""

    for e_opt (${args_options}); do
        case ${e_opt} in
            -a|--add)
                parse_regexp="${parse_regexp}|A"
                ;;
            -d|--delete)
                parse_regexp="${parse_regexp}|D"
                ;;
            -m|--modify)
                parse_regexp="${parse_regexp}|M"
                ;;
            -u|--untracked)
                parse_regexp="${parse_regexp}|\?\?"
                ;;
            -n)
                number_only=1
                ;;
            *)
                ;;
        esac
    ; done

    [[ ${#parse_regexp} < 1 ]] && {
        return 0
    } || {
        parse_regexp="($(echo ${parse_regexp} | sed 's!^|!!'))"
    }

    git-in-repository; [[ $? == 0 ]] && {
        parse_result=$(
            git status --porcelain 2>/dev/null                    | \
                egrep "^ *${parse_regexp}" 2>/dev/null            | \
                xargs -L1 | cut -d' ' -f1                         | \
                sed 's!??!?!g;s!.!@&!g' | tr '@' '\n' | xargs -L1 | \
                sort | uniq -c | xargs -L1                        | \
                tr 'ADM?' 'admu' | sed 's!^\(.\) \(.\)$!\2\1!g'   | \
                grep '^[audm]'
        )

        [[ ${number_only} == 1 && ${number_of_targets} == 2 ]] && {
            echo ${$(echo ${parse_result} | grep '^[audm][0-9]*' | grep -o '[0-9]*'):-0}
        } || {
            echo ${parse_result}
        }

        return 0
    }

    return -1
}
